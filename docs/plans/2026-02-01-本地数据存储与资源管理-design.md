# 本地数据存储与资源管理 - 设计方案

## 📋 概述

实现完整的本地数据存储功能，将项目、角色、数字人形象、剧本、场景视频等所有数据和资源文件保存到本地 SQLite 数据库和文件系统中，采用本地优先策略，保护用户隐私。

## 🎯 设计目标

- **本地优先模式**：所有数据主要存储在本地，服务端作为可选的同步目标
- **完整数据保存**：项目、角色、数字人、剧本、场景、视频等完整数据
- **资源本地化**：图片、视频等资源文件下载并永久保存在本地
- **隐私保护**：用户数据不强制上传到服务端，保护用户隐私
- **离线可用**：支持完全离线工作，无需依赖网络

## 🗄️ 数据库表结构设计

### 1. projects 表 - 项目主表

```sql
CREATE TABLE IF NOT EXISTS projects (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  topic TEXT NOT NULL,
  title TEXT,
  status TEXT NOT NULL,
  current_step TEXT NOT NULL,
  theme_name TEXT,
  theme_desc TEXT,
  created_at DATETIME NOT NULL,
  updated_at DATETIME NOT NULL
);
```

### 2. project_characters 表 - 项目角色

```sql
CREATE TABLE IF NOT EXISTS project_characters (
  id TEXT PRIMARY KEY,
  project_id TEXT NOT NULL,
  name TEXT NOT NULL,
  description TEXT NOT NULL,
  avatar_url TEXT,              -- 本地文件路径
  attributes TEXT,              -- JSON 字符串
  sort_order INTEGER NOT NULL,
  created_at DATETIME NOT NULL,
  updated_at DATETIME NOT NULL,
  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE
);
```

### 3. digital_humans 表 - 数字人形象

```sql
CREATE TABLE IF NOT EXISTS digital_humans (
  id TEXT PRIMARY KEY,
  character_id TEXT NOT NULL,
  image_url TEXT NOT NULL,      -- 本地文件路径
  prompt TEXT NOT NULL,
  is_selected INTEGER NOT NULL DEFAULT 0,
  created_at DATETIME NOT NULL,
  FOREIGN KEY (character_id) REFERENCES project_characters(id) ON DELETE CASCADE
);
```

### 4. project_scripts 表 - 项目剧本

```sql
CREATE TABLE IF NOT EXISTS project_scripts (
  id TEXT PRIMARY KEY,
  project_id TEXT NOT NULL,
  character_id TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  version INTEGER NOT NULL,
  is_active INTEGER NOT NULL DEFAULT 0,
  created_at DATETIME NOT NULL,
  updated_at DATETIME NOT NULL,
  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
  FOREIGN KEY (character_id) REFERENCES project_characters(id)
);
```

### 5. script_scenes 表 - 剧本场景

```sql
CREATE TABLE IF NOT EXISTS script_scenes (
  id TEXT PRIMARY KEY,
  script_id TEXT NOT NULL,
  title TEXT NOT NULL,
  sort_order INTEGER NOT NULL,
  duration INTEGER,
  content TEXT NOT NULL,        -- JSON 字符串，存储 SceneContent
  created_at DATETIME NOT NULL,
  updated_at DATETIME NOT NULL,
  FOREIGN KEY (script_id) REFERENCES project_scripts(id) ON DELETE CASCADE
);
```

### 6. scene_videos 表 - 场景视频

```sql
CREATE TABLE IF NOT EXISTS scene_videos (
  id TEXT PRIMARY KEY,
  scene_id TEXT NOT NULL,
  video_url TEXT NOT NULL,      -- 本地文件路径
  thumbnail_url TEXT,           -- 本地文件路径
  duration INTEGER,
  prompt TEXT NOT NULL,
  prompt_type TEXT NOT NULL,
  status TEXT NOT NULL,
  task_id TEXT,
  error_message TEXT,
  metadata TEXT,                -- JSON 字符串
  is_selected INTEGER NOT NULL DEFAULT 0,
  created_at DATETIME NOT NULL,
  updated_at DATETIME NOT NULL,
  FOREIGN KEY (scene_id) REFERENCES script_scenes(id) ON DELETE CASCADE
);
```

### 7. resource_downloads 表 - 资源下载状态管理

```sql
CREATE TABLE IF NOT EXISTS resource_downloads (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  resource_type TEXT NOT NULL,  -- 'character_avatar', 'digital_human', 'scene_video', 'video_thumbnail'
  resource_id TEXT NOT NULL,
  remote_url TEXT NOT NULL,
  local_path TEXT,
  status TEXT NOT NULL,         -- 'pending', 'downloading', 'completed', 'failed'
  error_message TEXT,
  file_size INTEGER,
  downloaded_size INTEGER,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(resource_type, resource_id)
);
```

## 📁 资源文件存储结构

### 目录组织

```
userData/
├── database/
│   └── app.db                  # SQLite 数据库
└── resources/
    └── projects/
        └── {projectId}/
            ├── characters/
            │   └── {characterId}/
            │       ├── avatar.jpg          # 角色头像
            │       └── digital-humans/
            │           ├── {dhId}_1.jpg    # 数字人形象1
            │           └── {dhId}_2.jpg    # 数字人形象2
            └── scenes/
                └── {sceneId}/
                    ├── video.mp4           # 场景视频
                    └── thumbnail.jpg       # 视频缩略图
```

### 文件命名规则

- 保留原始文件扩展名（.jpg, .png, .mp4 等）
- 使用资源 ID 作为文件名，避免冲突
- 支持文件去重（相同 URL 只下载一次）

## 🔧 Electron API 扩展

### database.js 新增方法

#### 项目管理
```javascript
// 保存项目到本地
function saveProject(project) { ... }

// 获取项目详情
function getProject(projectId) { ... }

// 获取所有项目列表
function getProjects() { ... }

// 删除项目（级联删除相关数据和资源文件）
function deleteProject(projectId) { ... }
```

#### 角色管理
```javascript
// 保存角色
function saveCharacter(character) { ... }

// 获取项目的所有角色
function getProjectCharacters(projectId) { ... }

// 删除角色
function deleteCharacter(characterId) { ... }
```

#### 数字人管理
```javascript
// 保存数字人形象
function saveDigitalHuman(digitalHuman) { ... }

// 获取角色的数字人列表
function getDigitalHumans(characterId) { ... }

// 删除数字人
function deleteDigitalHuman(digitalHumanId) { ... }
```

#### 剧本和场景
```javascript
// 保存剧本
function saveScript(script) { ... }

// 获取项目剧本
function getProjectScripts(projectId) { ... }

// 保存场景
function saveScene(scene) { ... }

// 获取剧本场景
function getScriptScenes(scriptId) { ... }

// 保存场景视频
function saveSceneVideo(video) { ... }
```

#### 资源下载管理
```javascript
// 下载资源文件
function downloadResource(url, localPath, resourceType, resourceId) { ... }

// 获取下载状态
function getResourceDownloadStatus(resourceType, resourceId) { ... }

// 重试下载
function retryDownload(resourceType, resourceId) { ... }

// 批量下载资源
function batchDownloadResources(resources) { ... }
```

### preload.js 接口暴露

```typescript
contextBridge.exposeInMainWorld('electron', {
  db: {
    // 现有方法...

    // 项目管理
    saveProject: (project) => ipcRenderer.invoke('db:saveProject', project),
    getProject: (projectId) => ipcRenderer.invoke('db:getProject', projectId),
    getProjects: () => ipcRenderer.invoke('db:getProjects'),
    deleteProject: (projectId) => ipcRenderer.invoke('db:deleteProject', projectId),

    // 角色管理
    saveCharacter: (character) => ipcRenderer.invoke('db:saveCharacter', character),
    getProjectCharacters: (projectId) => ipcRenderer.invoke('db:getProjectCharacters', projectId),
    deleteCharacter: (characterId) => ipcRenderer.invoke('db:deleteCharacter', characterId),

    // 数字人管理
    saveDigitalHuman: (digitalHuman) => ipcRenderer.invoke('db:saveDigitalHuman', digitalHuman),
    getDigitalHumans: (characterId) => ipcRenderer.invoke('db:getDigitalHumans', characterId),
    deleteDigitalHuman: (digitalHumanId) => ipcRenderer.invoke('db:deleteDigitalHuman', digitalHumanId),

    // 剧本和场景
    saveScript: (script) => ipcRenderer.invoke('db:saveScript', script),
    getProjectScripts: (projectId) => ipcRenderer.invoke('db:getProjectScripts', projectId),
    saveScene: (scene) => ipcRenderer.invoke('db:saveScene', scene),
    getScriptScenes: (scriptId) => ipcRenderer.invoke('db:getScriptScenes', scriptId),
    saveSceneVideo: (video) => ipcRenderer.invoke('db:saveSceneVideo', video),
  },

  resources: {
    downloadResource: (params) => ipcRenderer.invoke('resources:download', params),
    getDownloadStatus: (resourceType, resourceId) => ipcRenderer.invoke('resources:getStatus', resourceType, resourceId),
    retryDownload: (resourceType, resourceId) => ipcRenderer.invoke('resources:retry', resourceType, resourceId),
    batchDownload: (resources) => ipcRenderer.invoke('resources:batchDownload', resources),
  }
});
```

### TypeScript 类型定义

```typescript
// 扩展 ElectronAPI 接口
export interface ElectronAPI {
  db: {
    // 现有方法...

    // 项目管理
    saveProject: (project: Project) => Promise<boolean>;
    getProject: (projectId: string) => Promise<Project | null>;
    getProjects: () => Promise<Project[]>;
    deleteProject: (projectId: string) => Promise<boolean>;

    // 角色管理
    saveCharacter: (character: ProjectCharacter) => Promise<boolean>;
    getProjectCharacters: (projectId: string) => Promise<ProjectCharacter[]>;
    deleteCharacter: (characterId: string) => Promise<boolean>;

    // 数字人管理
    saveDigitalHuman: (digitalHuman: DigitalHuman) => Promise<boolean>;
    getDigitalHumans: (characterId: string) => Promise<DigitalHuman[]>;
    deleteDigitalHuman: (digitalHumanId: string) => Promise<boolean>;

    // 剧本和场景
    saveScript: (script: ProjectScript) => Promise<boolean>;
    getProjectScripts: (projectId: string) => Promise<ProjectScript[]>;
    saveScene: (scene: ScriptScene) => Promise<boolean>;
    getScriptScenes: (scriptId: string) => Promise<ScriptScene[]>;
    saveSceneVideo: (video: SceneVideo) => Promise<boolean>;
  };

  resources: {
    downloadResource: (params: DownloadResourceParams) => Promise<DownloadResult>;
    getDownloadStatus: (resourceType: string, resourceId: string) => Promise<ResourceDownloadStatus>;
    retryDownload: (resourceType: string, resourceId: string) => Promise<DownloadResult>;
    batchDownload: (resources: DownloadResourceParams[]) => Promise<BatchDownloadResult>;
  };
}

// 资源下载参数
export interface DownloadResourceParams {
  url: string;
  resourceType: 'character_avatar' | 'digital_human' | 'scene_video' | 'video_thumbnail';
  resourceId: string;
  projectId: string;
  characterId?: string;
  sceneId?: string;
}

// 下载结果
export interface DownloadResult {
  success: boolean;
  localPath?: string;
  error?: string;
}

// 资源下载状态
export interface ResourceDownloadStatus {
  status: 'pending' | 'downloading' | 'completed' | 'failed';
  progress?: number;
  localPath?: string;
  error?: string;
}

// 批量下载结果
export interface BatchDownloadResult {
  total: number;
  succeeded: number;
  failed: number;
  results: DownloadResult[];
}
```

## 🔄 数据流转逻辑

### 创建/更新项目流程

```typescript
// 1. 调用服务端 API（保留现有逻辑）
const project = await createProject(data);

// 2. 保存到本地数据库
await window.electron.db.saveProject(project);

// 3. 下载资源文件（异步）
if (project.characters) {
  const downloadTasks = [];

  for (const char of project.characters) {
    // 下载角色头像
    if (char.avatarUrl) {
      downloadTasks.push(
        window.electron.resources.downloadResource({
          url: char.avatarUrl,
          resourceType: 'character_avatar',
          resourceId: char.id,
          projectId: project.id,
          characterId: char.id,
        })
      );
    }

    // 下载数字人形象
    if (char.digitalHumans) {
      for (const dh of char.digitalHumans) {
        downloadTasks.push(
          window.electron.resources.downloadResource({
            url: dh.imageUrl,
            resourceType: 'digital_human',
            resourceId: dh.id,
            projectId: project.id,
            characterId: char.id,
          })
        );
      }
    }
  }

  // 批量下载
  const results = await Promise.allSettled(downloadTasks);

  // 处理下载失败的情况
  const failed = results.filter(r => r.status === 'rejected' || !r.value.success);
  if (failed.length > 0) {
    // 显示错误提示
    showDownloadErrorNotification(failed.length);
  }
}
```

### 读取项目流程

```typescript
// 1. 优先读取本地数据
let project = await window.electron.db.getProject(projectId);

// 2. 如果本地不存在，从服务端获取
if (!project) {
  project = await getProject(projectId);  // 服务端 API

  // 保存到本地
  if (project) {
    await window.electron.db.saveProject(project);
    // 触发资源下载...
  }
}

// 3. 加载角色和数字人
const characters = await window.electron.db.getProjectCharacters(projectId);

for (const char of characters) {
  // 加载数字人列表
  char.digitalHumans = await window.electron.db.getDigitalHumans(char.id);
}

project.characters = characters;
```

### 资源路径处理

```typescript
// 工具函数：获取资源 URL
function getResourceUrl(localPath: string | null, remoteUrl: string): string {
  // 优先使用本地路径
  if (localPath && fs.existsSync(localPath)) {
    return `file://${localPath}`;
  }

  // 降级使用远程 URL
  return remoteUrl;
}

// 使用示例
<img src={getResourceUrl(character.avatarUrl, character.remoteAvatarUrl)} />
```

## 🎨 UI 调整

### 资源下载状态显示

```typescript
// 下载状态徽章组件
function ResourceStatusBadge({ resourceType, resourceId }: Props) {
  const [status, setStatus] = useState<ResourceDownloadStatus | null>(null);

  useEffect(() => {
    loadStatus();
  }, [resourceType, resourceId]);

  const loadStatus = async () => {
    const s = await window.electron.resources.getDownloadStatus(resourceType, resourceId);
    setStatus(s);
  };

  const handleRetry = async () => {
    await window.electron.resources.retryDownload(resourceType, resourceId);
    loadStatus();
  };

  if (!status || status.status === 'completed') {
    return null;
  }

  return (
    <div className="flex items-center gap-2">
      {status.status === 'downloading' && (
        <Badge variant="secondary">
          <Loader2 className="w-3 h-3 mr-1 animate-spin" />
          下载中 {status.progress}%
        </Badge>
      )}

      {status.status === 'failed' && (
        <div className="flex items-center gap-2">
          <Badge variant="destructive">
            <XCircle className="w-3 h-3 mr-1" />
            下载失败
          </Badge>
          <Button size="sm" variant="outline" onClick={handleRetry}>
            重试
          </Button>
          <Button size="sm" variant="ghost" onClick={() => showContactSupport()}>
            联系官方
          </Button>
        </div>
      )}
    </div>
  );
}
```

### 下载失败提示

```typescript
// 显示下载错误通知
function showDownloadErrorNotification(failedCount: number) {
  toast({
    title: "资源下载失败",
    description: `有 ${failedCount} 个资源下载失败，请检查网络连接后重试，或联系官方技术支持处理。`,
    variant: "destructive",
    action: (
      <ToastAction altText="联系官方" onClick={() => showContactSupport()}>
        联系官方
      </ToastAction>
    ),
  });
}

// 显示联系官方对话框
function showContactSupport() {
  // 显示包含官方联系方式的对话框
  // 可以包含：客服邮箱、QQ群、微信等
}
```

### 本地/云端数据源标识

```typescript
// 数据源指示器
function DataSourceIndicator({ isLocal }: { isLocal: boolean }) {
  return (
    <Badge variant={isLocal ? "secondary" : "outline"}>
      {isLocal ? (
        <>
          <HardDrive className="w-3 h-3 mr-1" />
          本地
        </>
      ) : (
        <>
          <Cloud className="w-3 h-3 mr-1" />
          云端
        </>
      )}
    </Badge>
  );
}
```

## 📋 实施计划

### 阶段一：数据库和资源管理基础（3-5天）

**任务清单：**
1. 扩展 SQLite 表结构
   - 创建 7 张新表
   - 添加索引和外键约束
   - 编写数据迁移脚本

2. 实现资源文件下载模块
   - 实现 downloadResource 函数
   - 支持进度回调
   - 支持断点续传（可选）
   - 错误重试机制

3. 实现资源存储管理
   - 创建目录结构
   - 文件命名和去重
   - 文件完整性校验

4. 扩展 Electron API
   - 实现 database.js 新增方法
   - 实现 preload.js 接口暴露
   - 添加 IPC 通信处理

**验收标准：**
- [ ] 数据库表创建成功
- [ ] 资源下载功能正常
- [ ] 文件存储结构正确
- [ ] Electron API 可正常调用

### 阶段二：项目和角色本地化（3-5天）

**任务清单：**
1. 修改项目创建/更新流程
   - 服务端操作后同步保存到本地
   - 触发资源下载
   - 更新下载状态

2. 修改角色管理流程
   - 保存角色到本地数据库
   - 下载头像和数字人图片
   - 处理下载失败情况

3. 调整 ProjectDetail 页面
   - 优先读取本地数据
   - 显示下载状态
   - 添加重试按钮

4. 添加 UI 组件
   - ResourceStatusBadge 组件
   - DataSourceIndicator 组件
   - 下载错误提示

**验收标准：**
- [ ] 项目数据保存到本地
- [ ] 角色数据保存到本地
- [ ] 资源文件下载成功
- [ ] UI 正确显示状态
- [ ] 下载失败时提示正确

### 阶段三：剧本和视频本地化（3-5天）

**任务清单：**
1. 实现剧本和场景的本地存储
   - 保存剧本到本地数据库
   - 保存场景到本地数据库
   - 处理 JSON 字段序列化

2. 实现场景视频的下载和存储
   - 下载视频文件
   - 下载缩略图
   - 处理大文件下载

3. 调整相关页面
   - ProjectScripts 页面
   - ScriptEditor 页面
   - SceneVideos 页面

4. 添加批量下载功能
   - 批量下载场景视频
   - 显示整体进度
   - 支持暂停/继续

**验收标准：**
- [ ] 剧本数据保存到本地
- [ ] 场景数据保存到本地
- [ ] 视频文件下载成功
- [ ] 批量下载功能正常
- [ ] 大文件下载性能可接受

### 阶段四：优化和完善（2-3天）

**任务清单：**
1. 数据迁移和备份
   - 导出本地数据
   - 导入本地数据
   - 数据备份功能

2. 性能优化
   - 并发下载控制
   - 下载队列管理
   - 缓存策略优化

3. 存储空间管理
   - 计算存储使用量
   - 清理未使用资源
   - 存储空间统计

4. 错误处理完善
   - 完善错误提示
   - 添加日志记录
   - 异常恢复机制

**验收标准：**
- [ ] 数据导入导出正常
- [ ] 下载性能满足要求
- [ ] 存储管理功能完善
- [ ] 错误处理健壮

## 🧪 测试要点

### 功能测试
- [ ] 数据库表创建和数据 CRUD
- [ ] 资源文件下载和存储
- [ ] 本地路径回显正常
- [ ] 下载失败时提示正确
- [ ] 重试下载功能正常
- [ ] 删除项目时级联删除资源文件
- [ ] 批量下载功能正常

### 性能测试
- [ ] 大文件下载性能（100MB+ 视频）
- [ ] 并发下载性能（10+ 资源同时下载）
- [ ] 数据库查询性能（1000+ 项目）
- [ ] UI 响应性能（资源加载不阻塞 UI）

### 边界测试
- [ ] 网络断开时的处理
- [ ] 磁盘空间不足时的处理
- [ ] 文件权限错误时的处理
- [ ] 数据库损坏时的恢复

### 兼容性测试
- [ ] Windows 系统
- [ ] macOS 系统
- [ ] Linux 系统（如果支持）

## ⚠️ 潜在风险和注意事项

### 1. 存储空间管理
**风险：** 视频文件可能占用大量磁盘空间

**应对措施：**
- 提供存储空间统计功能
- 支持清理未使用的资源
- 提醒用户磁盘空间不足
- 支持选择性下载（用户可选择不下载某些资源）

### 2. 下载性能
**风险：** 大量资源下载可能耗时较长

**应对措施：**
- 后台异步下载，不阻塞 UI
- 并发下载控制（限制同时下载数量）
- 支持断点续传（可选）
- 显示下载进度和预计时间

### 3. 数据一致性
**风险：** 本地和服务端数据可能不一致

**应对措施：**
- 明确本地优先策略
- 提供数据同步功能（可选）
- 记录数据版本和更新时间
- 冲突时优先使用本地数据

### 4. 数据迁移
**风险：** 现有用户的数据需要迁移到本地

**应对措施：**
- 首次启动时自动从服务端拉取数据
- 提供手动同步功能
- 显示迁移进度
- 支持增量同步

### 5. 文件路径处理
**风险：** 不同操作系统的路径格式不同

**应对措施：**
- 使用 Node.js 的 path 模块处理路径
- 统一使用 file:// 协议
- 测试多平台兼容性

### 6. 隐私和安全
**风险：** 本地数据可能被未授权访问

**应对措施：**
- 数据库文件权限控制
- 考虑数据加密（可选）
- 提供数据清除功能
- 遵守隐私保护法规

## 📝 后续优化建议

1. **数据加密**
   - 对敏感数据进行加密存储
   - 使用用户密码派生密钥

2. **云端同步**
   - 支持多设备同步
   - 冲突解决策略
   - 增量同步优化

3. **离线编辑**
   - 完全离线工作模式
   - 离线编辑队列
   - 联网后自动同步

4. **数据压缩**
   - 压缩存储视频文件
   - 减少磁盘占用

5. **智能缓存**
   - LRU 缓存策略
   - 自动清理旧资源
   - 预加载常用资源

## 🎉 预期效果

1. **用户体验提升**
   - 资源永久保存，不会被清理
   - 离线可用，不依赖网络
   - 加载速度更快（本地读取）

2. **隐私保护**
   - 数据存储在本地，用户完全控制
   - 不强制上传到服务端
   - 符合隐私保护要求

3. **性能提升**
   - 减少网络请求
   - 本地读取速度快
   - 降低服务端压力

4. **可靠性提升**
   - 不受服务端清理影响
   - 数据持久化保存
   - 支持离线工作

---

**设计完成时间：** 2026-02-01
**预计实施周期：** 11-18 天
**优先级：** 高
