# AiChat 视频生成直接调用 实施计划

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** 让 AiChat 在选中 video_gen 模型时，直接调用 VideoGenConfig 配置的 API 接口生成视频，而非走 chat completion。

**Architecture:** 前端检测 video_gen 模式后渲染参数卡片 + 图片上传，通过新增的 IPC 通道（video:upload / video:generate / video:pollStatus）调用 Electron 主进程，主进程根据 VideoGenConfig 动态构建请求并解析响应。

**Tech Stack:** React + TypeScript, Electron IPC, VideoGenConfig 动态接口配置

---

### Task 1: 新增类型定义

**Files:**
- Modify: `client/src/types/index.ts`

**Step 1: 添加视频生成相关类型**

在 `AiChatStreamChunk` 之后添加：

```typescript
// 视频生成请求参数
export interface VideoGenerateRequest {
  baseUrl: string;
  apiKey: string;
  generateConfig: EndpointConfig;
  prompt: string;
  imageUrl?: string;
  paramValues: Record<string, string | number | boolean>;
  conversationId?: string;
  modelConfigId?: string;
  modelName?: string;
}

// 视频生成响应
export interface VideoGenerateResult {
  success: boolean;
  taskId?: string;
  error?: string;
  rawResponse?: any;
}

// 视频状态轮询请求
export interface VideoPollStatusRequest {
  baseUrl: string;
  apiKey: string;
  statusConfig: EndpointConfig;
  taskId: string;
}

// 视频状态轮询响应
export interface VideoPollStatusResult {
  success: boolean;
  status?: string;
  videoUrl?: string;
  thumbnailUrl?: string;
  error?: string;
  rawResponse?: any;
}

// 视频上传请求
export interface VideoUploadRequest {
  baseUrl: string;
  apiKey: string;
  uploadConfig: EndpointConfig;
  filePath: string;
}

// 视频上传响应
export interface VideoUploadResult {
  success: boolean;
  imageUrl?: string;
  error?: string;
}

// 视频生成进度状态（前端用）
export interface VideoGenProgress {
  stage: 'uploading' | 'submitting' | 'generating' | 'completed' | 'failed';
  taskId?: string;
  status?: string;
  videoUrl?: string;
  thumbnailUrl?: string;
  error?: string;
}
```

**Step 2: 扩展 ChatMessage 类型**

修改 `ChatMessage` 接口，添加可选的视频元数据：

```typescript
export interface ChatMessage {
  id: string;
  conversationId: string;
  role: 'user' | 'assistant';
  content: string;
  modelName: string | null;
  createdAt: string;
  // 视频生成相关
  videoMeta?: {
    taskId?: string;
    videoUrl?: string;
    thumbnailUrl?: string;
    prompt?: string;
    params?: Record<string, any>;
    status?: string;
  } | null;
}
```

**Step 3: 扩展 window.electron 类型**

在 `ElectronAPI` 接口中添加 `video` 命名空间：

```typescript
video: {
  generate: (request: VideoGenerateRequest) => Promise<VideoGenerateResult>;
  pollStatus: (request: VideoPollStatusRequest) => Promise<VideoPollStatusResult>;
  upload: (request: VideoUploadRequest) => Promise<VideoUploadResult>;
};
```

**Step 4: Commit**

```bash
git add client/src/types/index.ts
git commit -m "feat: 添加视频生成直接调用相关类型定义"
```

---

### Task 2: Electron preload 暴露视频 IPC

**Files:**
- Modify: `client/electron/preload.ts`

**Step 1: 添加 video 命名空间**

在 `chat` 命名空间之后添加：

```typescript
// 视频生成
video: {
  generate: (request: any) => ipcRenderer.invoke('video:generate', request),
  pollStatus: (request: any) => ipcRenderer.invoke('video:pollStatus', request),
  upload: (request: any) => ipcRenderer.invoke('video:upload', request),
},
```

**Step 2: Commit**

```bash
git add client/electron/preload.ts
git commit -m "feat: preload 暴露视频生成 IPC 通道"
```

---

### Task 3: Electron 主进程 — 视频 IPC handler

**Files:**
- Modify: `client/electron/main.ts`

**Step 1: 添加 getByPath 工具函数**

在 `chat:sendMessage` handler 之前添加：

```typescript
// 从嵌套对象中按点号路径取值
function getByPath(obj: any, path: string): any {
  return path.split('.').reduce((o, k) => o?.[k], obj);
}

// 将点号路径的 key 设置到嵌套对象中
function setByPath(obj: any, path: string, value: any): void {
  const keys = path.split('.');
  let current = obj;
  for (let i = 0; i < keys.length - 1; i++) {
    if (!(keys[i] in current)) current[keys[i]] = {};
    current = current[keys[i]];
  }
  current[keys[keys.length - 1]] = value;
}
```

**Step 2: 添加 video:generate handler**

在 `chat:sendMessage` handler 之后添加：

```typescript
ipcMain.handle('video:generate', async (event, request: any) => {
  const { baseUrl, apiKey, generateConfig, prompt, imageUrl, paramValues,
          conversationId, modelConfigId, modelName } = request;
  const logId = crypto.randomUUID();
  const startTime = Date.now();

  try {
    // 构建请求体
    const body: any = {};
    // prompt 直接放入
    body.prompt = prompt;
    // 如果有图片 URL
    if (imageUrl) {
      body.image_url = imageUrl;
    }
    // 遍历参数配置，用 paramValues 覆盖默认值
    for (const param of generateConfig.params) {
      if (param.type === 'file') continue; // 文件类型跳过
      const value = paramValues[param.key] !== undefined ? paramValues[param.key] : param.value;
      setByPath(body, param.key, value);
    }

    const url = baseUrl.replace(/\/+$/, '') + generateConfig.path;
    const response = await fetch(url, {
      method: generateConfig.method,
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(body),
    });

    const responseText = await response.text();
    let responseJson: any;
    try { responseJson = JSON.parse(responseText); } catch { responseJson = null; }

    if (!response.ok) {
      // 记录日志
      saveAiUsageLog({
        id: logId, toolType: 'video_gen', modelName: modelName || null,
        modelConfigId: modelConfigId || null, status: 'error',
        errorMessage: `HTTP ${response.status}: ${responseText.slice(0, 2000)}`,
        durationMs: Date.now() - startTime,
        requestBody: JSON.stringify({ url, body }),
        responseBody: responseText.slice(0, 5000),
        userInput: prompt.slice(0, 500), baseUrl,
        conversationId: conversationId || null,
        createdAt: new Date().toISOString(),
      });
      return { success: false, error: `HTTP ${response.status}: ${responseText.slice(0, 500)}` };
    }

    // 用 responseMapping 解析 taskId
    let taskId: string | undefined;
    for (const mapping of generateConfig.responseMapping) {
      if (mapping.key === 'taskId' && responseJson) {
        taskId = String(getByPath(responseJson, mapping.path));
      }
    }

    // 记录成功日志
    saveAiUsageLog({
      id: logId, toolType: 'video_gen', modelName: modelName || null,
      modelConfigId: modelConfigId || null, status: 'success',
      durationMs: Date.now() - startTime,
      requestBody: JSON.stringify({ url, body }),
      responseBody: responseText.slice(0, 5000),
      userInput: prompt.slice(0, 500), aiOutput: taskId || '',
      baseUrl, conversationId: conversationId || null,
      createdAt: new Date().toISOString(),
    });

    return { success: true, taskId, rawResponse: responseJson };
  } catch (error: any) {
    saveAiUsageLog({
      id: logId, toolType: 'video_gen', modelName: modelName || null,
      modelConfigId: modelConfigId || null, status: 'error',
      errorMessage: error.message, durationMs: Date.now() - startTime,
      requestBody: JSON.stringify({ prompt, paramValues }),
      userInput: prompt.slice(0, 500), baseUrl,
      conversationId: conversationId || null,
      createdAt: new Date().toISOString(),
    });
    return { success: false, error: error.message };
  }
});
```

**Step 3: 添加 video:pollStatus handler**

```typescript
ipcMain.handle('video:pollStatus', async (event, request: any) => {
  const { baseUrl, apiKey, statusConfig, taskId } = request;

  try {
    // 替换路径中的 {taskId}
    const path = statusConfig.path.replace('{taskId}', taskId);
    const url = baseUrl.replace(/\/+$/, '') + path;

    const response = await fetch(url, {
      method: statusConfig.method,
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
    });

    const responseText = await response.text();
    let responseJson: any;
    try { responseJson = JSON.parse(responseText); } catch { responseJson = null; }

    if (!response.ok) {
      return { success: false, error: `HTTP ${response.status}: ${responseText.slice(0, 500)}` };
    }

    // 用 responseMapping 解析字段
    const result: any = { success: true, rawResponse: responseJson };
    for (const mapping of statusConfig.responseMapping) {
      if (responseJson) {
        result[mapping.key] = getByPath(responseJson, mapping.path);
      }
    }

    return result;
  } catch (error: any) {
    return { success: false, error: error.message };
  }
});
```

**Step 4: 添加 video:upload handler**

```typescript
ipcMain.handle('video:upload', async (event, request: any) => {
  const { baseUrl, apiKey, uploadConfig, filePath } = request;

  try {
    const url = baseUrl.replace(/\/+$/, '') + uploadConfig.path;

    // 找到 type=file 的参数，获取字段名
    const fileParam = uploadConfig.params.find((p: any) => p.type === 'file');
    const fieldName = fileParam?.key || 'file';

    // 读取文件并构建 FormData
    const fileBuffer = await fs.readFile(filePath);
    const fileName = path.basename(filePath);
    const blob = new Blob([fileBuffer]);
    const formData = new FormData();
    formData.append(fieldName, blob, fileName);

    const response = await fetch(url, {
      method: uploadConfig.method,
      headers: {
        'Authorization': `Bearer ${apiKey}`,
      },
      body: formData,
    });

    const responseText = await response.text();
    let responseJson: any;
    try { responseJson = JSON.parse(responseText); } catch { responseJson = null; }

    if (!response.ok) {
      return { success: false, error: `HTTP ${response.status}: ${responseText.slice(0, 500)}` };
    }

    // 用 responseMapping 解析 imageUrl
    let imageUrl: string | undefined;
    for (const mapping of uploadConfig.responseMapping) {
      if (mapping.key === 'imageUrl' && responseJson) {
        imageUrl = String(getByPath(responseJson, mapping.path));
      }
    }

    return { success: true, imageUrl };
  } catch (error: any) {
    return { success: false, error: error.message };
  }
});
```

**Step 5: Commit**

```bash
git add client/electron/main.ts
git commit -m "feat: 添加视频生成/轮询/上传 IPC handler"
```

---

### Task 4: 前端 videoService 服务层

**Files:**
- Create: `client/src/services/videoGenService.ts`

**Step 1: 创建服务文件**

```typescript
import {
  VideoGenerateRequest, VideoGenerateResult,
  VideoPollStatusRequest, VideoPollStatusResult,
  VideoUploadRequest, VideoUploadResult,
} from '../types';

export async function videoGenerate(request: VideoGenerateRequest): Promise<VideoGenerateResult> {
  return window.electron.video.generate(request);
}

export async function videoPollStatus(request: VideoPollStatusRequest): Promise<VideoPollStatusResult> {
  return window.electron.video.pollStatus(request);
}

export async function videoUpload(request: VideoUploadRequest): Promise<VideoUploadResult> {
  return window.electron.video.upload(request);
}
```

**Step 2: Commit**

```bash
git add client/src/services/videoGenService.ts
git commit -m "feat: 添加视频生成服务层"
```

---

### Task 5: 视频参数卡片组件

**Files:**
- Create: `client/src/components/VideoParamPanel.tsx`

**Step 1: 创建参数面板组件**

该组件从 `EndpointConfig.params` 读取参数列表，渲染对应的输入控件，维护 `paramValues` 状态。

- `select` → 下拉选择器，显示 options，默认选中 value
- `boolean` → 复选框，显示 label
- `number` → 数字输入框
- `string` → 文本输入框
- `file` → 不渲染（由上传按钮单独处理）
- 有 `remark` 的参数 hover 显示 tooltip

Props:
```typescript
interface VideoParamPanelProps {
  params: ParamField[];
  values: Record<string, string | number | boolean>;
  onChange: (values: Record<string, string | number | boolean>) => void;
}
```

**Step 2: Commit**

```bash
git add client/src/components/VideoParamPanel.tsx
git commit -m "feat: 视频参数卡片组件"
```

---

### Task 6: 视频进度条组件

**Files:**
- Create: `client/src/components/VideoProgressBar.tsx`

**Step 1: 创建悬浮进度条组件**

显示在聊天区顶部，展示当前视频生成状态。

Props:
```typescript
interface VideoProgressBarProps {
  progress: VideoGenProgress;
  onCancel?: () => void;
}
```

状态映射：
- `uploading` → "上传图片中..."
- `submitting` → "提交生成任务..."
- `generating` → "视频生成中..." + 状态文字
- `completed` → "生成完成"（自动隐藏）
- `failed` → "生成失败: {error}"

**Step 2: Commit**

```bash
git add client/src/components/VideoProgressBar.tsx
git commit -m "feat: 视频生成悬浮进度条组件"
```

---

### Task 7: 视频播放器消息气泡组件

**Files:**
- Create: `client/src/components/VideoMessageBubble.tsx`

**Step 1: 创建视频消息气泡组件**

在 assistant 消息中展示视频结果：小尺寸内嵌播放器 + 点击全屏预览。

Props:
```typescript
interface VideoMessageBubbleProps {
  videoUrl: string;
  thumbnailUrl?: string;
  prompt?: string;
  params?: Record<string, any>;
  onSave?: () => void;
  onSaveAs?: () => void;
}
```

包含：
- 小尺寸 `<video>` 播放器（320x180）
- 点击打开全屏预览 modal
- prompt 摘要显示
- 保存/另存为按钮

**Step 2: Commit**

```bash
git add client/src/components/VideoMessageBubble.tsx
git commit -m "feat: 视频播放器消息气泡组件"
```

---

### Task 8: AiChat.tsx 集成视频生成模式

**Files:**
- Modify: `client/src/pages/system/AiChat.tsx`

**Step 1: 添加视频模式状态**

```typescript
// 视频生成模式状态
const [videoParamValues, setVideoParamValues] = useState<Record<string, string | number | boolean>>({});
const [videoProgress, setVideoProgress] = useState<VideoGenProgress | null>(null);
const [uploadedImagePath, setUploadedImagePath] = useState<string | null>(null);
const [uploadedImageUrl, setUploadedImageUrl] = useState<string | null>(null);
const [videoPreviewUrl, setVideoPreviewUrl] = useState<string | null>(null);
const pollTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);
```

**Step 2: 初始化参数默认值**

当 selectedConfig 变化且为 video_gen 时，从 extraConfig.endpoints.generate.params 初始化默认值：

```typescript
useEffect(() => {
  if (selectedConfig?.toolType === 'video_gen' && selectedConfig.extraConfig) {
    const defaults: Record<string, string | number | boolean> = {};
    for (const p of selectedConfig.extraConfig.endpoints.generate.params) {
      if (p.type !== 'file') defaults[p.key] = p.value;
    }
    setVideoParamValues(defaults);
  }
}, [selectedConfig]);
```

**Step 3: 实现视频发送逻辑 handleVideoSend**

替代 handleSend，当 video_gen 模式时调用：

1. 如果有上传图片 → 调用 video:upload 拿到 imageUrl
2. 调用 video:generate 提交任务，拿到 taskId
3. 启动定时器轮询 video:pollStatus（每 4 秒）
4. 轮询到 completed → 更新消息气泡为视频播放器
5. 轮询到 failed → 显示错误

**Step 4: 渲染视频模式 UI**

- 输入区上方：`<VideoParamPanel>` 参数卡片
- 输入区左侧：上传图片按钮（调用 electron dialog 选择文件）
- 聊天区顶部：`<VideoProgressBar>` 悬浮进度条（生成中显示）
- assistant 消息：检测 videoMeta 存在时渲染 `<VideoMessageBubble>`

**Step 5: 视频全屏预览 modal**

复用现有的 previewImage 模式，新增 videoPreviewUrl 状态，渲染全屏 `<video>` 播放器。

**Step 6: Commit**

```bash
git add client/src/pages/system/AiChat.tsx
git commit -m "feat: AiChat 集成视频生成模式"
```

---

### Task 9: 对话列表生成中状态标识

**Files:**
- Modify: `client/src/pages/system/AiChat.tsx`

**Step 1: 在对话列表项中显示生成状态**

当 `videoProgress` 不为 null 且 `activeConvId` 匹配时，在对话列表项旁显示一个小动画图标（Loader2 spin）。

**Step 2: Commit**

```bash
git add client/src/pages/system/AiChat.tsx
git commit -m "feat: 对话列表显示视频生成中状态"
```

---

### Task 10: 整体测试与清理

**Step 1: 手动测试流程**

1. 在 AiToolManagement 中配置一个 video_gen 工具（如 Sora 预设）
2. 在 AiChat 中选择该工具
3. 确认参数卡片正确渲染所有参数及默认值
4. 输入 prompt 发送，确认调用 generate 接口
5. 确认轮询 status 接口
6. 确认视频结果展示

**Step 2: 最终 Commit**

```bash
git add -A
git commit -m "feat: AiChat 视频生成直接调用完整实现"
```
