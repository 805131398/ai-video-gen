# Client 角色视图 - 适配新数据结构

**日期**: 2026-01-29
**类型**: Bug Fix
**问题**: 角色视图没有显示内容，而场景视图和时间轴视图有数据

## 问题描述

用户反馈：剧本的"场景视图"和"时间轴视图"中都有数据，但是"角色视图"中没有内容显示。

### 问题原因

Client 的类型定义和 CharacterView 组件使用的是旧的数据结构，而 Web 后端已经更新为新的数据结构，导致数据不匹配。

**旧数据结构**：
```typescript
interface SceneContent {
  characters: Array<{
    characterId: string;
    characterName: string;
    action: string;
    emotion: string;
    position: 'left' | 'center' | 'right';
  }>;
  dialogues: Array<{
    characterId: string;
    text: string;
    speed: 'slow' | 'normal' | 'fast';
    tone: string;
  }>;
}
```

**新数据结构**：
```typescript
interface SceneContent {
  characterId: string; // 主要角色
  otherCharacters?: Array<{
    characterId: string;
    role: string;
  }>;
  actions: {
    entrance: string;
    main: string;
    exit: string;
  };
  dialogues: Array<{
    text: string;
    speaker: string; // 角色名称
  }>;
}
```

## 解决方案

### 1. 更新 Client 类型定义

**文件**: `client/src/types/index.ts`

更新 `SceneContent` 接口，使其与 Web 后端的数据结构完全一致：

```typescript
export interface SceneContent {
  description: string;
  characterId: string; // 主要角色ID
  otherCharacters?: Array<{
    characterId: string;
    role: string; // 在场景中的角色描述
  }>;
  actions: {
    entrance: string; // 入场动作
    main: string;     // 主要动作
    exit: string;     // 出场动作
  };
  dialogues: Array<{
    text: string;
    speaker: string; // 说话人（角色名称）
  }>;
  camera: {
    type: 'fixed' | 'follow' | 'orbit' | 'handheld';
    movement: 'push' | 'pull' | 'pan' | 'tilt' | 'dolly';
    shotSize: 'closeup' | 'close' | 'medium' | 'full' | 'wide';
    description: string;
  };
  visual: {
    lighting: 'daylight' | 'night' | 'indoor' | 'golden' | 'overcast';
    mood: 'warm' | 'cool' | 'vintage' | 'vibrant' | 'muted';
    effects: string;
    description: string;
  };
  audio: {
    bgMusic: string;
    soundEffects: string;
    volume: number;
  };
}
```

### 2. 更新 CharacterView 组件

**文件**: `client/src/components/project/CharacterView.tsx`

#### 更新场景过滤逻辑

```typescript
const characterDialogues = scenes.flatMap((scene) => {
  // 检查角色是否是主要角色
  const isMainCharacter = scene.content.characterId === character.id;

  // 检查角色是否在其他角色列表中
  const otherCharacterInfo = scene.content.otherCharacters?.find(
    (c) => c.characterId === character.id
  );

  // 如果角色不在这个场景中，跳过
  if (!isMainCharacter && !otherCharacterInfo) return [];

  // 过滤该角色的台词（通过说话人名称匹配）
  const dialogues = scene.content.dialogues?.filter(
    (d) => d.speaker === character.name
  ) || [];

  // 获取角色在场景中的角色描述
  const role = isMainCharacter ? '主要角色' : otherCharacterInfo?.role || '其他角色';

  return [{
    scene,
    dialogues,
    role,
    isMainCharacter,
  }];
});
```

#### 更新 UI 显示

1. **添加角色标签**：显示角色是"主要角色"还是其他角色（如"接受治疗的患者"）
2. **更新动作显示**：显示 entrance、main、exit 三种动作
3. **简化台词显示**：只显示台词文本，移除 speed 和 tone（新结构中没有这些字段）

```tsx
<div className="flex items-center gap-2 mt-1">
  {scene.duration && (
    <span className="text-xs text-slate-500">⏱ {scene.duration}s</span>
  )}
  <span className={`text-xs px-2 py-0.5 rounded ${
    isMainCharacter
      ? 'bg-blue-100 text-blue-700'
      : 'bg-slate-200 text-slate-700'
  }`}>
    {role}
  </span>
</div>

{/* 显示动作 */}
{scene.content.actions && (
  <div className="mb-3">
    <p className="text-xs font-medium text-slate-600 mb-1">动作：</p>
    <div className="space-y-1">
      {scene.content.actions.entrance && (
        <p className="text-sm text-slate-700">
          • 入场：{scene.content.actions.entrance}
        </p>
      )}
      {scene.content.actions.main && (
        <p className="text-sm text-slate-700">
          • 主要：{scene.content.actions.main}
        </p>
      )}
      {scene.content.actions.exit && (
        <p className="text-sm text-slate-700">
          • 出场：{scene.content.actions.exit}
        </p>
      )}
    </div>
  </div>
)}
```

## UI 效果

### 角色视图显示

```
┌─────────────────────────────────────────┐
│ [头像] 草根老中医                        │
│        3 个场景                          │
├─────────────────────────────────────────┤
│ ┌─────────────────────────────────────┐ │
│ │ 温情诊疗          ⏱ 15s [主要角色]  │ │
│ │                          [编辑场景]  │ │
│ │                                     │ │
│ │ 动作：                              │ │
│ │ • 入场：中医从药房走出，父亲已坐在  │ │
│ │   椅子上等待                        │ │
│ │ • 主要：将茶杯稳稳放在父亲面前，    │ │
│ │   眼神温柔地注视着他                │ │
│ │ • 出场：中医转身回到药房，父亲起身  │ │
│ │   离开                              │ │
│ │                                     │ │
│ │ 台词：                              │ │
│ │ "这茶能帮你缓解疼痛，慢慢喝，别着急"│ │
│ └─────────────────────────────────────┘ │
│                                         │
│ ┌─────────────────────────────────────┐ │
│ │ 父亲康复          ⏱ 12s [其他角色]  │ │
│ │                          [编辑场景]  │ │
│ │                                     │ │
│ │ 台词：                              │ │
│ │ "谢谢您，这些天好多了"              │ │
│ └─────────────────────────────────────┘ │
└─────────────────────────────────────────┘
```

## 功能特点

### 1. 支持多角色场景

- ✅ 显示主要角色的场景
- ✅ 显示其他角色的场景
- ✅ 区分角色在场景中的作用（主要角色 vs 其他角色）

### 2. 角色标签

- ✅ 主要角色：蓝色标签
- ✅ 其他角色：灰色标签，显示具体角色描述（如"接受治疗的患者"）

### 3. 动作显示

- ✅ 显示入场动作
- ✅ 显示主要动作
- ✅ 显示出场动作
- ✅ 支持多角色互动描述

### 4. 台词过滤

- ✅ 通过说话人名称（speaker）匹配角色
- ✅ 只显示该角色的台词
- ✅ 简洁的台词显示（移除了旧结构中的 speed 和 tone）

## 数据流

### 场景过滤流程

```
遍历所有场景
    ↓
检查角色是否是主要角色 (characterId)
    ↓
检查角色是否在其他角色列表中 (otherCharacters)
    ↓
如果角色在场景中
    ↓
过滤该角色的台词 (speaker === character.name)
    ↓
获取角色在场景中的角色描述
    ↓
返回场景信息
```

## 修改的文件

1. **修改**: `client/src/types/index.ts`
   - 更新 `SceneContent` 接口，使其与 Web 后端一致
   - 添加 `characterId`、`otherCharacters`、`actions` 等字段
   - 更新 `dialogues`、`camera`、`visual`、`audio` 字段

2. **修改**: `client/src/components/project/CharacterView.tsx`
   - 更新场景过滤逻辑，支持主要角色和其他角色
   - 更新台词过滤，使用 `speaker` 名称匹配
   - 更新动作显示，显示 entrance、main、exit
   - 添加角色标签，区分主要角色和其他角色
   - 简化台词显示

## 测试验证

### 测试用例 1：主要角色场景

**场景数据**：
```json
{
  "title": "温情诊疗",
  "content": {
    "characterId": "中医ID",
    "otherCharacters": [
      {
        "characterId": "父亲ID",
        "role": "接受治疗的患者"
      }
    ],
    "actions": {
      "entrance": "中医从药房走出，父亲已坐在椅子上等待",
      "main": "将茶杯稳稳放在父亲面前，眼神温柔地注视着他",
      "exit": "中医转身回到药房，父亲起身离开"
    },
    "dialogues": [
      {
        "text": "这茶能帮你缓解疼痛，慢慢喝，别着急",
        "speaker": "草根老中医"
      }
    ]
  }
}
```

**预期结果**：
- ✅ 中医角色视图显示该场景
- ✅ 显示"主要角色"标签（蓝色）
- ✅ 显示三种动作（入场、主要、出场）
- ✅ 显示中医的台词

### 测试用例 2：其他角色场景

**场景数据**：
```json
{
  "title": "温情诊疗",
  "content": {
    "characterId": "中医ID",
    "otherCharacters": [
      {
        "characterId": "父亲ID",
        "role": "接受治疗的患者"
      }
    ],
    "dialogues": [
      {
        "text": "谢谢您，这些天好多了",
        "speaker": "父亲"
      }
    ]
  }
}
```

**预期结果**：
- ✅ 父亲角色视图显示该场景
- ✅ 显示"接受治疗的患者"标签（灰色）
- ✅ 显示父亲的台词

### 测试用例 3：角色不在场景中

**场景数据**：
```json
{
  "title": "开场引入",
  "content": {
    "characterId": "主播ID",
    "dialogues": [
      {
        "text": "大家好，欢迎来到我的频道",
        "speaker": "主播"
      }
    ]
  }
}
```

**预期结果**：
- ✅ 中医和父亲的角色视图不显示该场景
- ✅ 主播的角色视图显示该场景

## 用户体验提升

### 之前
- ❌ 角色视图没有内容显示
- ❌ 数据结构不匹配
- ❌ 无法看到角色在场景中的作用

### 现在
- ✅ 角色视图正常显示内容
- ✅ 数据结构与后端一致
- ✅ 清晰显示角色在场景中的作用（主要角色 vs 其他角色）
- ✅ 显示完整的动作信息（入场、主要、出场）
- ✅ 准确过滤角色的台词

## 总结

通过更新 Client 的类型定义和 CharacterView 组件，成功实现了：

1. ✅ 类型定义与 Web 后端完全一致
2. ✅ 支持多角色场景（主要角色 + 其他角色）
3. ✅ 准确过滤和显示角色的场景和台词
4. ✅ 清晰的角色标签，区分主要角色和其他角色
5. ✅ 完整的动作显示（入场、主要、出场）

现在角色视图可以正常显示内容，用户可以清楚地看到每个角色在哪些场景中出现，以及他们的台词和动作。
