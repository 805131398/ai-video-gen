# 视频生成轮询服务 - 服务重启恢复机制

## 问题描述

当服务端重启后，内存中的视频生成轮询任务会丢失，导致：

1. **任务"卡住"**：数据库中的任务状态停留在 `generating`，但没有后台任务继续轮询
2. **前端无法更新**：前端继续轮询状态查询 API，但数据库中的状态不再更新
3. **用户体验差**：用户看到进度停滞不前，不知道任务是否还在进行

## 解决方案

实现了一个**视频轮询服务**（VideoPollingService），提供以下功能：

### 1. 服务启动时自动恢复

- 应用启动时，自动查询所有未完成的任务（status = "pending" 或 "generating"）
- 为这些任务重新启动轮询
- 确保服务重启后任务能够继续执行

### 2. 定时检查"卡住"的任务

- 每 2 分钟检查一次是否有"卡住"的任务
- "卡住"的定义：status = "generating" 且 updatedAt 超过 3 分钟
- 自动重新启动这些任务的轮询

### 3. 防止重复轮询

- 使用 `activePollingTasks` Set 跟踪正在轮询的任务
- 启动轮询前检查任务是否已在轮询中
- 避免同一个任务被多次轮询

## 实现内容

### 1. 视频轮询服务

**文件**: `web/src/lib/services/video-polling-service.ts`

#### 核心功能

```typescript
// 启动服务（应用启动时调用）
export async function startVideoPollingService()

// 停止服务（应用关闭时调用）
export function stopVideoPollingService()

// 恢复未完成的任务
async function recoverUnfinishedTasks()

// 检查"卡住"的任务
async function checkStuckTasks()

// 轮询单个任务
export async function pollVideoStatus(
  videoId: string,
  taskId: string,
  videoClient: any
)
```

#### 恢复逻辑

```typescript
async function recoverUnfinishedTasks() {
  // 1. 查询所有未完成的任务
  const unfinishedVideos = await prisma.sceneVideo.findMany({
    where: {
      status: { in: ["pending", "generating"] },
      taskId: { not: null },
    },
    include: {
      scene: {
        include: {
          script: {
            include: {
              project: {
                include: { user: true },
              },
            },
          },
        },
      },
    },
  });

  // 2. 为每个任务重新启动轮询
  for (const video of unfinishedVideos) {
    if (activePollingTasks.has(video.id)) continue;

    const videoConfig = await getEffectiveAIConfig(...);
    const videoClient = createVideoClient(...);

    pollVideoStatus(video.id, video.taskId, videoClient).catch(...);
  }
}
```

#### 定时检查逻辑

```typescript
async function checkStuckTasks() {
  const threeMinutesAgo = new Date(Date.now() - 3 * 60 * 1000);

  // 查询"卡住"的任务
  const stuckVideos = await prisma.sceneVideo.findMany({
    where: {
      status: "generating",
      taskId: { not: null },
      updatedAt: { lt: threeMinutesAgo },
    },
  });

  // 重新启动轮询
  for (const video of stuckVideos) {
    if (activePollingTasks.has(video.id)) continue;
    // ... 重新启动轮询
  }
}
```

### 2. 应用初始化

**文件**: `web/src/lib/init.ts`

```typescript
export async function initializeApp() {
  if (initialized) return;

  console.log("[App] Initializing application...");

  // 启动视频轮询服务
  await startVideoPollingService();

  initialized = true;
}
```

### 3. 根布局集成

**文件**: `web/src/app/layout.tsx`

```typescript
import { initializeApp } from "@/lib/init";

// 在模块加载时初始化应用
initializeApp().catch((error) => {
  console.error("[RootLayout] Failed to initialize app:", error);
});

export default function RootLayout({ children }) {
  // ...
}
```

### 4. 视频生成 API 修改

**文件**: `web/src/app/api/projects/[id]/scripts/[scriptId]/scenes/[sceneId]/generate-video/route.ts`

```typescript
import { pollVideoStatus } from "@/lib/services/video-polling-service";

// 使用服务中的 pollVideoStatus，而不是本地函数
pollVideoStatus(sceneVideo.id, result.taskId, videoClient).catch(...);
```

## 工作流程

### 正常流程

```
1. 用户提交视频生成任务
2. API 创建 SceneVideo 记录（status = pending）
3. API 调用 toapis 提交任务
4. API 启动后台轮询（pollVideoStatus）
5. 轮询任务每 5 秒查询一次状态
6. 更新数据库中的 progress 和 status
7. 任务完成或失败后停止轮询
```

### 服务重启后的恢复流程

```
1. 服务重启
2. layout.tsx 加载，调用 initializeApp()
3. initializeApp() 调用 startVideoPollingService()
4. recoverUnfinishedTasks() 查询所有未完成的任务
5. 为每个任务重新启动轮询
6. 轮询继续执行，直到任务完成
```

### 定时检查流程

```
1. 每 2 分钟执行一次 checkStuckTasks()
2. 查询 status = "generating" 且 updatedAt > 3 分钟的任务
3. 为这些任务重新启动轮询
4. 防止任务因网络问题或其他原因"卡住"
```

## 防重复机制

使用 `activePollingTasks` Set 跟踪正在轮询的任务：

```typescript
const activePollingTasks = new Set<string>();

export async function pollVideoStatus(videoId, taskId, videoClient) {
  // 防止重复轮询
  if (activePollingTasks.has(videoId)) {
    console.log(`Task ${videoId} is already being polled`);
    return;
  }

  activePollingTasks.add(videoId);

  try {
    // 轮询逻辑...
  } finally {
    // 移除活跃任务标记
    activePollingTasks.delete(videoId);
  }
}
```

## 日志输出

服务会输出详细的日志，方便调试：

```
[VideoPollingService] Starting video polling service...
[VideoPollingService] Found 3 unfinished tasks to recover
[VideoPollingService] Recovering polling for task abc123 (taskId: video_xxx)
[VideoPollingService] Started polling for task abc123 (taskId: video_xxx)
[VideoPollingService] Video polling service started
[VideoPollingService] Found 1 stuck tasks
[VideoPollingService] Restarting polling for stuck task def456 (taskId: video_yyy)
[VideoPollingService] Video generated successfully for task abc123
[VideoPollingService] Stopped polling for task abc123
```

## 性能考虑

### 内存占用

- `activePollingTasks` Set 只存储任务 ID（字符串）
- 每个任务约占用 50-100 字节
- 100 个并发任务约占用 5-10 KB，可忽略不计

### 数据库查询

- **启动时**：查询一次所有未完成的任务
- **定时检查**：每 2 分钟查询一次"卡住"的任务
- **轮询**：每个任务每 5 秒更新一次数据库

### 优化建议

如果并发任务数量很大（>100），可以考虑：

1. **批量更新**：将多个任务的进度更新合并为一次数据库操作
2. **增加轮询间隔**：从 5 秒增加到 10 秒
3. **使用任务队列**：使用 Bull/BullMQ 等任务队列系统

## 测试验证

### 1. 测试服务重启恢复

```bash
# 1. 启动服务
pnpm dev

# 2. 提交视频生成任务
# 观察日志：[VideoPollingService] Started polling for task xxx

# 3. 重启服务（Ctrl+C 然后重新 pnpm dev）
# 观察日志：
# [VideoPollingService] Found 1 unfinished tasks to recover
# [VideoPollingService] Recovering polling for task xxx

# 4. 验证任务继续执行
# 前端卡片上的进度应该继续更新
```

### 2. 测试定时检查

```bash
# 1. 提交视频生成任务
# 2. 手动停止轮询（模拟任务"卡住"）
# 3. 等待 2 分钟
# 观察日志：
# [VideoPollingService] Found 1 stuck tasks
# [VideoPollingService] Restarting polling for stuck task xxx
```

### 3. 测试防重复机制

```bash
# 1. 提交视频生成任务
# 2. 立即重启服务
# 观察日志：
# [VideoPollingService] Task xxx is already being polled
# 确保任务不会被重复轮询
```

## 注意事项

1. **Next.js 开发模式**：开发模式下 Hot Reload 可能导致服务多次初始化，这是正常的
2. **生产环境**：生产环境下服务只会初始化一次
3. **数据库连接**：确保 Prisma 连接池配置合理，避免连接耗尽
4. **错误处理**：轮询失败时会记录日志，但不会影响其他任务

## 后续优化

1. **WebSocket 推送**：使用 WebSocket 替代轮询，实现真正的实时更新
2. **任务队列**：使用 Bull/BullMQ 等任务队列系统，支持分布式部署
3. **监控告警**：添加任务失败率、平均耗时等监控指标
4. **优雅关闭**：在服务关闭时等待所有轮询任务完成

## 相关文件

- `web/src/lib/services/video-polling-service.ts` - 视频轮询服务
- `web/src/lib/init.ts` - 应用初始化
- `web/src/app/layout.tsx` - 根布局（调用初始化）
- `web/src/app/api/projects/[id]/scripts/[scriptId]/scenes/[sceneId]/generate-video/route.ts` - 视频生成 API
